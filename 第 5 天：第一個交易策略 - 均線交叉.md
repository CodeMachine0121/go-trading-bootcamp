# 第 5 天：第一個交易策略 - 均線交叉

在過去的四天裡，我們完成了所有的準備工作：搭建了開發環境、掌握了 Go 的基礎語法、打通了與幣安的資料通道，並學會了如何組織和管理這些資料。

今天，我們將不再僅僅是資料的處理者，我們將成為策略的創造者。我們將利用前幾天計算的**移動平均線 (MA)**，構建量化交易世界中最經典、最廣為人知的入門策略之一——**均線交叉策略**。

我們將寫下能讓程式自主判斷「何時該買入」和「何時該賣出」的核心邏輯。

## 第一部分：交易策略 Domain Knowledge

### 1. 什麼是趨勢跟隨策略 (Trend-Following Strategy)？

均線交叉策略是「趨勢跟隨」策略家族中最基礎的一員。這類策略的核心思想非常樸素：

> 不試圖預測市場的頂部和底部，而是致力於在趨勢形成時「上車」，並跟隨趨向，直到趨勢結束的跡象出現時「下車」。

它的座右銘是「趨勢是你的朋友 (The trend is your friend)」。我們的均線交叉策略，就是用一種客觀、量化的方式來定義「趨勢的開始」和「趨勢的結束」。

### 2. 深入理解「均線交叉策略」

這個策略需要兩條不同週期的移動平均線：

- **一條快線 (Fast MA)**: 計算週期較短的移動平均線，例如 5 日均線 (5MA) 或 10 日均線 (10MA)。它對近期價格變化反應更靈敏。
- **一條慢線 (Slow MA)**: 計算週期較長的移動平均線，例如 20 日均線 (20MA) 或 30 日均線 (30MA)。它代表了市場的長期趨勢，反應較為遲鈍和平滑。
策略的核心，就是觀察這兩條線的相對位置和穿越行為。

### 3. 訊號解讀：黃金交叉與死亡交叉

#### 🌟 黃金交叉 (Golden Cross)
- **定義**: 當快線由下往上穿過慢線時，形成黃金交叉
- **訊號類型**: 看漲訊號 (Bullish Signal) 📈
- **市場意義**: 近期市場的平均成本已經超過了長期平均成本，表明市場動能可能正在從空頭轉向多頭
- **交易行動**: 考慮買入的訊號
- **趨勢預期**: 一輪上漲趨勢可能即將開始
- **形象比喻**: 就像一艘快艇（快線）加速超過了一艘巨大的遊輪（慢線）

#### ☠️ 死亡交叉 (Death Cross)
- **定義**: 當快線由上往下跌穿慢線時，形成死亡交叉
- **訊號類型**: 看跌訊號 (Bearish Signal) 📉
- **市場意義**: 近期市場的平均成本已經跌破了長期平均成本，表明市場動能可能正在從多頭轉向空頭
- **交易行動**: 考慮賣出或平倉的訊號
- **趨勢預期**: 一輪下跌趨勢可能即將開始

#### 📊 快速對比

| 項目 | 黃金交叉 🌟 | 死亡交叉 ☠️ |
|------|-------------|-------------|
| 快線方向 | 由下往上穿過慢線 ↗️ | 由上往下跌穿慢線 ↘️ |
| 市場情緒 | 看漲 (Bullish) | 看跌 (Bearish) |
| 建議行動 | 考慮買入 💰 | 考慮賣出 📤 |

### 4. 認識「回測 (Backtesting)」

我們今天將在歷史資料上尋找這些交叉訊號，並這個在歷史資料上驗證策略表現的過程，就叫做**回測**。一個策略在歷史資料上能否盈利，是它在真實市場中可能表現如何的重要參考（但絕不是保證）。
今天我們將進行一次最簡單的回測，用眼睛來觀察訊號的出現。

## 第二部分：Coding 實作

我們的目標很明確： 

- 獲取足夠長的歷史 K 線資料，遍歷每一根 K 線。
- 計算出當下和上一根 K 線的快線和慢線值。
- 比較這四個值，判斷是否發生了交叉。
- 如果發生交叉，就在終端機印出明確的訊號。

請用以下完整程式碼替換你的 main.go 檔案。我們在昨天的基礎上進行了擴充，加入了策略判斷的核心邏輯。

```golang
package main

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/adshao/go-binance/v2"
)

// Kline 結構體保持不變
type Kline struct {
	OpenTime time.Time
	Open     float64
	High     float64
	Low      float64
	Close    float64
	Volume   float64
}

// calculateSMA 函式保持不變
func calculateSMA(prices []float64, period int) (float64, error) {
	if len(prices) < period {
		return 0, fmt.Errorf("資料點不足")
	}
	var sum float64
	for _, price := range prices[len(prices)-period:] {
		sum += price
	}
	return sum / float64(period), nil
}

func main() {
	// --- 1. 資料準備 ---
	client := binance.NewClient("", "")
	// 獲取更多資料以便進行交叉判斷，例如 100 根 4 小時 K 線
	binanceKlines, err := client.NewKlinesService().Symbol("BTCUSDT").
		Interval("4h").Limit(100).Do(context.Background())
	if err != nil {
		fmt.Println("獲取 K 線失敗:", err)
		return
	}

	var klines []Kline
	var closingPrices []float64
	for _, bk := range binanceKlines {
		closePrice, _ := strconv.ParseFloat(bk.Close, 64)
		kline := Kline{
			OpenTime: time.Unix(bk.OpenTime/1000, 0),
			Close:    closePrice,
		}
		klines = append(klines, kline)
		closingPrices = append(closingPrices, closePrice)
	}
	fmt.Printf("成功獲取並轉換了 %d 根 BTC/USDT 4小時 K 線資料。\n", len(klines))
	fmt.Println("--------------------------------------------------")

	// --- 2. 策略邏輯與訊號產生 ---
	fastPeriod := 10 // 快線週期
	slowPeriod := 20 // 慢線週期

	fmt.Printf("開始檢測週期為 %d 和 %d 的均線交叉訊號...\n\n", fastPeriod, slowPeriod)

	// 我們從 slowPeriod 的位置開始遍歷，因為這樣才能確保有足夠的資料計算慢線
	for i := slowPeriod; i < len(closingPrices); i++ {
		// 獲取當前時間點可用的所有歷史價格
		pricesSoFar := closingPrices[:i+1]

		// 計算當前的快線和慢線
		fastMA, _ := calculateSMA(pricesSoFar, fastPeriod)
		slowMA, _ := calculateSMA(pricesSoFar, slowPeriod)

		// 獲取上一時間點的歷史價格
		pricesPrev := closingPrices[:i]

		// 計算上一根 K 線的快線和慢線
		prevFastMA, _ := calculateSMA(pricesPrev, fastPeriod)
		prevSlowMA, _ := calculateSMA(pricesPrev, slowPeriod)

		// --- 核心判斷邏輯 ---
		// 判斷黃金交叉: 上一刻快線在慢線下方，且當前快線在慢線上方
		if prevFastMA < prevSlowMA && fastMA > slowMA {
			fmt.Printf(
				"[買入訊號] 黃金交叉! 時間: %s, 收盤價: %.2f, 快線: %.2f, 慢線: %.2f\n",
				klines[i].OpenTime.Format("2006-01-02 15:04"),
				klines[i].Close,
				fastMA,
				slowMA,
			)
		}

		// 判斷死亡交叉: 上一刻快線在慢線上方，且當前快線在慢線下方
		if prevFastMA > prevSlowMA && fastMA < slowMA {
			fmt.Printf(
				"[賣出訊號] 死亡交叉! 時間: %s, 收盤價: %.2f, 快線: %.2f, 慢線: %.2f\n",
				klines[i].OpenTime.Format("2006-01-02 15:04"),
				klines[i].Close,
				fastMA,
				slowMA,
			)
		}
	}
}
```

### 程式碼解析：

- `fastPeriod`, `slowPeriod`: 我們將策略的參數定義為變數，方便未來調整和優化。
- `for i := slowPeriod; ...`: 我們的迴圈不是從 0 開始，而是從 slowPeriod 開始。這是因為在第 20 根 K 線之前，我們根本沒有足夠的資料來計算 20MA，所以必須跳過這些無法計算的點。
- `pricesSoFar`, `pricesPrev`: 這是本策略的精髓所在。為了判斷「交叉」這個「動作」，我們必須同時知道「現在」和「過去」的狀態。所以我們需要分別計算當前 K 線 (i) 和上一根 K 線 (i-1) 的均線值。
- `if prevFastMA < prevSlowMA && fastMA > slowMA`: 這行程式碼完美地用邏輯語言翻譯了「黃金交叉」的定義。死亡交叉的判斷同理。

### 運行程式：

在終端機中執行 `go run main.go`，你將看到程式在分析完資料後，印出它在過去 100 根 K 線中找到的所有交叉訊號，例如：

```text
成功獲取並轉換了 100 根 BTC/USDT 4小時 K 線資料。
--------------------------------------------------
開始檢測週期為 10 和 20 的均線交叉訊號...

[買入訊號] 黃金交叉! 時間: 2025-07-28 08:00, 收盤價: 68540.10, 快線: 68210.55, 慢線: 68190.23
[賣出訊號] 死亡交叉! 時間: 2025-08-09 00:00, 收盤價: 69810.70, 快線: 69950.40, 慢線: 69980.11
...（其他可能的訊號）
```

(注意：你看到的具體時間和價格會與此不同，因為 K 線資料是不斷變化的)

## 本日總結與預告
今天，我們不再只是被動地接收資料，而是主動地從資料中提取出了有價值的交易訊號，也已經成功地將一個完整的交易思想（均線交叉）轉化為了具體、可執行的 Go 程式碼。這是從程式設計師到量化交易者身份轉變的關鍵一步。

但是，產生訊號只是第一步。一個真正的交易者還需要根據訊號去執行交易。目前我們的程式還只是個「分析師」，只能動口（印日誌），不能動手（下單）。

明天 (第 6 天)，我們將為我們的程式賦予「手」。我們將學習如何申請幣安的 API Key，並連線到幣安測試網 (Testnet)——一個可以用模擬資金進行真實 API 操作的完美練習場，為我們最終的自動化下單做好一切準備。
我們明天見！