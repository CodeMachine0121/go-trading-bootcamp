# 第 3 天：透過 API 讀取幣安市場行情

在第二天，我們掌握了 Golang 的基礎語法，並用它來計算一個靜態的、我們手動輸入的價格數列的移動平均值。這很棒，但量化交易的魅力在於與真實、即時的市場互動。
今天，我們將邁出至關重要的一步：打通我們的 Go 程式與幣安交易所之間的數據通道，我們將學習如何使用 API (應用程式介面) 來獲取真實的市場 K 線數據，讓我們昨天的 calculateSMA 函式能有用武之地。

## 第一部分：交易策略 Domain Knowledge

### 1. 市場數據的語言：K 線 (Candlestick Chart)

如果你看過任何交易軟體，你一定見過紅紅綠綠的柱狀圖，這就是 K 線。每一根 K 棒都包含了四個核心價格資訊和一個成交量資訊，它們合稱為 **OHLCV**：

- **O (Open)**: 開盤價。某個時間週期開始時的第一筆成交價。
- **H (High)**: 最高價。該週期內的最高成交價。
- **L (Low)**: 最低價。該週期內的最低成交價。
- **C (Close)**: 收盤價。該週期結束時的最後一筆成交價。這是最重要的價格，因為它代表了該週期結束時市場的多空共識，我們昨天計算移動平均用的就是收盤價。
- **V (Volume)**: 成交量。該週期內總共成交的資產數量。

例如，一根「日線」級別的 K 棒，就記錄了 `BTC/USDT` 在一整天內的開盤價、最高價、最低價、收盤價和總成交量。K 線是技術分析的基石，也是我們策略的數據來源。

### 2. 幣安 API 的兩種介面

- **公開介面 (Public Endpoints)**: 用於獲取公開的市場數據，例如 K 線、市場深度、即時價格等。訪問這些介面不需要身份驗證，任何人都可以直接請求。今天我們將使用這個。
- **私有介面 (Private Endpoints)**: 用於操作你的個人帳戶，例如下單、查詢餘額、取消訂單等。訪問這些介面必須提供你的 API Key 和 Secret Key 來證明你的身份。我們將在第 6 天學習如何使用它。

## 第二部分：Coding 實作

今天，我們將使用 go-binance SDK 來取得幣安的資訊，這將是我們未來更常用的方式。

### 步驟 1: 安裝 go-binance SDK

首先，我們需要將社群開發的幣安 SDK 下載到我們的專案中。在你的專案資料夾 (go-quant-binance) 的終端機中，執行以下指令：

```bash
go get github.com/adshao/go-binance/v2
```

> go get 指令會自動下載這個函式庫，並在你的 go.mod 檔案中記錄下這個依賴。

### 步驟 2: 撰寫程式碼獲取 K 線

打開你的 main.go 檔案，用下面的程式碼替換所有內容。這段程式碼包含了詳細的註解，請仔細閱讀。

```golang
package main

import (
	"context"
	"fmt"
	"time"

	"github.com/adshao/go-binance/v2"
)

func main() {
	fmt.Println("--- 使用 go-binance SDK 獲取數據 ---")

	// 初始化一個幣安客戶端。因為我們只訪問公開數據，所以 API Key 和 Secret Key 可以留空。
	client := binance.NewClient("", "")

	// 使用 KlinesService 來請求 K 線數據
	// .Symbol("BTCUSDT")  - 指定交易對
	// .Interval("1h")     - 指定 K 線的時間間隔 (1h 代表 1 小時)
	// .Limit(5)          - 指定獲取最近 5 根 K 線
	// .Do(context.Background()) - 執行請求
	klines, err := client.NewKlinesService().Symbol("BTCUSDT").
		Interval("1h").Limit(5).Do(context.Background())

	// 錯誤處理
	if err != nil {
		fmt.Println("透過 SDK 獲取 K 線失敗:", err)
		return
	}

	// klines 是一個包含了 K 線數據的切片，讓我們遍歷它並印出
	fmt.Println("成功獲取 BTC/USDT 最近 5 根 1 小時 K 線:")
	for _, k := range klines {
		fmt.Printf(
			"開盤時間: %s, 開盤價: %s, 最高價: %s, 最低價: %s, 收盤價: %s\n",
			// k.OpenTime 是毫秒時間戳，我們需要將它轉換成人類可讀的格式
			time.Unix(k.OpenTime/1000, 0).Format("2006-01-02 15:04:05"),
			k.Open,
			k.High,
			k.Low,
			k.Close,
		)
	}
}
```

#### 運行程式：

在終端機中執行 `go run main.go`。如果網路正常，你將會看到類似下面的輸出（具體價格會隨時間變化）：

```text
--- 使用 go-binance SDK 獲取數據 ---
成功獲取 BTC/USDT 最近 5 根 1 小時 K 線:
開盤時間: 2025-08-18 20:00:00, 開盤價: 114947.27000000, 最高價: 115520.00000000, 最低價: 114902.94000000, 收盤價: 115519.99000000
開盤時間: 2025-08-18 21:00:00, 開盤價: 115520.00000000, 最高價: 115736.54000000, 最低價: 114825.00000000, 收盤價: 114839.13000000
開盤時間: 2025-08-18 22:00:00, 開盤價: 114839.14000000, 最高價: 115633.73000000, 最低價: 114839.14000000, 收盤價: 115633.73000000
開盤時間: 2025-08-18 23:00:00, 開盤價: 115633.72000000, 最高價: 116186.97000000, 最低價: 115402.00000000, 收盤價: 116145.34000000
開盤時間: 2025-08-19 00:00:00, 開盤價: 116145.34000000, 最高價: 116350.00000000, 最低價: 115818.86000000, 收盤價: 115962.24000000
```

## 本日總結與預告
今天我們打通了任督二脈，讓Go 程式第一次與真實的金融世界產生了連結。

我們學習了 K 線數據 (OHLCV) 的含義，理解了 API 的工作原理，並成功地使用 go-binance SDK 從幣安交易所獲取了真實的市場行情數據，也親身體會到了使用 SDK 的便利性——它替我們處理了所有複雜的網路請求和數據解析工作。

現在我們有了源源不斷的數據來源。明天 (第 4 天)，我們將學習如何用 Go 的 Structs, Slices 和 Maps 這些強大的工具，來優雅地儲存和組織這些從 API 獲取來的數據，為我們後續的策略分析和計算做好準備。
我們明天見！